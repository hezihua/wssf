(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{449:function(t,r,a){"use strict";a.r(r);var e=a(2),s=Object(e.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"数据卷"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据卷"}},[t._v("#")]),t._v(" 数据卷")]),t._v(" "),r("h1",{attrs:{id:"数据卷相当于是容器的虚拟文件系统和主机的真实文件系统之间的一个桥梁-建立数据卷就相当于是打通了容器于主机之间的文件交互通道-可以让容器运行时所产生的数据变更被保存到主机中-能够更方便的对数据进行备份以及保护"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据卷相当于是容器的虚拟文件系统和主机的真实文件系统之间的一个桥梁-建立数据卷就相当于是打通了容器于主机之间的文件交互通道-可以让容器运行时所产生的数据变更被保存到主机中-能够更方便的对数据进行备份以及保护"}},[t._v("#")]),t._v(" 数据卷相当于是容器的虚拟文件系统和主机的真实文件系统之间的一个桥梁，建立数据卷就相当于是打通了容器于主机之间的文件交互通道，可以让容器运行时所产生的数据变更被保存到主机中，能够更方便的对数据进行备份以及保护")]),t._v(" "),r("p",[t._v("docker run --rm -d -p 80:80 -v /www/test nginx  --匿名数据卷")]),t._v(" "),r("p",[t._v("docker run --rm -d -p 80:80 -v nginx-www:/www/test nginx  --具名数据卷")]),t._v(" "),r("p",[t._v("Docker 为我们提供了一些专门用于管理数据卷的命令 docker volume   --数据卷管理")]),t._v(" "),r("h1",{attrs:{id:"网络"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#网络"}},[t._v("#")]),t._v(" 网络")]),t._v(" "),r("h1",{attrs:{id:"是-docker-对容器网络隔离的一项技术-提供了多种不同的模式供用户使用-选择不同的网络模式来实现容器网络的互通以及彻底的隔离。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#是-docker-对容器网络隔离的一项技术-提供了多种不同的模式供用户使用-选择不同的网络模式来实现容器网络的互通以及彻底的隔离。"}},[t._v("#")]),t._v(" 是 Docker 对容器网络隔离的一项技术，提供了多种不同的模式供用户使用，选择不同的网络模式来实现容器网络的互通以及彻底的隔离。")]),t._v(" "),r("h1",{attrs:{id:"网络模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#网络模式"}},[t._v("#")]),t._v(" 网络模式")]),t._v(" "),r("p",[t._v("docker network ls  --查看网络模式")]),t._v(" "),r("h1",{attrs:{id:"bridge-网络模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bridge-网络模式"}},[t._v("#")]),t._v(" bridge --网络模式")]),t._v(" "),r("p",[t._v("bridge 网络模式需要在创建容器时通过参数  --net bridge 或者 --network bridge")]),t._v(" "),r("h1",{attrs:{id:"host-网络模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#host-网络模式"}},[t._v("#")]),t._v(" host 网络模式")]),t._v(" "),r("p",[t._v("host 网络模式需要在创建容器时通过参数 --net host 或者 --network host 指定；\n采用 host 网络模式的 Docker Container，可以直接使用宿主机的 IP 地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有 IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换；")]),t._v(" "),r("h1",{attrs:{id:"none-网络模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#none-网络模式"}},[t._v("#")]),t._v(" none 网络模式")]),t._v(" "),r("p",[t._v("none 网络模式 --net none 或者 --network none")]),t._v(" "),r("h1",{attrs:{id:"container-网络模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#container-网络模式"}},[t._v("#")]),t._v(" container 网络模式")]),t._v(" "),r("p",[t._v("Container 网络模式是 Docker 中一种较为特别的网络的模式。在创建容器时通过参数 --net container:已运行的容器名称|ID 或者 --network container:已运行的容器名称|ID 指定；\n处于这个模式下的 Docker 容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信。")]),t._v(" "),r("h1",{attrs:{id:"自定义网络"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自定义网络"}},[t._v("#")]),t._v(" 自定义网络")]),t._v(" "),r("p",[t._v("docker network create  --创建网络")]),t._v(" "),r("h1",{attrs:{id:"连接网络"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#连接网络"}},[t._v("#")]),t._v(" 连接网络")]),t._v(" "),r("p",[t._v("通过 docker network connect 网络名称 容器名称 为容器连接新的网络模式。")]),t._v(" "),r("h1",{attrs:{id:"断开网络"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#断开网络"}},[t._v("#")]),t._v(" 断开网络")]),t._v(" "),r("p",[t._v("通过 docker network disconnect 网络名称 容器名称 命令断开网络。")]),t._v(" "),r("h1",{attrs:{id:"移除网络"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#移除网络"}},[t._v("#")]),t._v(" 移除网络")]),t._v(" "),r("p",[t._v("可以通过 docker network rm 网络名称 命令移除自定义网络模式，网络模式移除成功会返回网络模式名称。")]),t._v(" "),r("h1",{attrs:{id:"容器间通信"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#容器间通信"}},[t._v("#")]),t._v(" 容器间通信")]),t._v(" "),r("p",[t._v("两个属于同一个网络的容器是可以进行网络通信的，默认需要通过ip 进行通信，创建容器时使用 --name 可以使用容器名进行通信")])])}),[],!1,null,null,null);r.default=s.exports}}]);